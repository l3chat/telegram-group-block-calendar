<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Group Booking Calendar</title>

  <!-- FullCalendar -->
  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    :root {
      --mine-bg: #c8f7c5;
      --mine-border: #2e7d32;
      --theirs-bg: #ffd6cc;
      --theirs-border: #c62828;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background:#fff; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 10px 12px 24px; }
    #legend { display:flex; gap:16px; align-items:center; font-size:14px; margin: 6px 2px 10px; color:#333; }
    .pill { display:inline-flex; align-items:center; gap:8px; }
    .dot { width:14px; height:14px; border-radius:4px; border:1px solid; display:inline-block; }
    .dot.mine   { background: var(--mine-bg);   border-color: var(--mine-border); }
    .dot.theirs { background: var(--theirs-bg); border-color: var(--theirs-border); }

    /* events: clickable, non-editable, black text */
    .fc-event { cursor: pointer; }
    .fc-event.mine {
      background: var(--mine-bg) !important;
      border-color: var(--mine-border) !important;
    }
    .fc-event.theirs {
      background: var(--theirs-bg) !important;
      border-color: var(--theirs-border) !important;
    }
    .fc-event.mine,
    .fc-event.mine .fc-event-main,
    .fc-event.theirs,
    .fc-event.theirs .fc-event-main,
    .fc-event-title {
      color: #000 !important;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="legend">
      <span class="pill"><span class="dot mine"></span> My bookings</span>
      <span class="pill"><span class="dot theirs"></span> Others’ bookings</span>
    </div>
    <div id="calendar"></div>
  </div>

  <script>
    // Telegram init
    try { Telegram.WebApp.ready?.(); Telegram.WebApp.expand?.(); } catch {}

    // ---- parameters from URL / initData
    const qs = new URLSearchParams(location.search);
    const CHAT_ID  = qs.get('chat_id');
    const TOPIC_ID = qs.get('topic_id') || '';
    const INGEST   = qs.get('ingest') || '';
    const UID_QS   = Number(qs.get('uid') || '0');
    const UNAME_QS = qs.get('uname') || 'via WebApp';

    const initUnsafe = Telegram?.WebApp?.initDataUnsafe || {};
    const fromUnsafe = initUnsafe.user || null;

    const UID   = fromUnsafe?.id ?? UID_QS;
    const UNAME = (fromUnsafe
      ? [fromUnsafe.first_name, fromUnsafe.last_name].filter(Boolean).join(' ').trim()
      : UNAME_QS) || 'via WebApp';

    // ---- base API URL (strip /ingest)
    let apiBase = '';
    try {
      const u = new URL(INGEST);
      apiBase = u.origin + u.pathname.replace(/\/ingest\/?$/, '');
    } catch {}

    const BOOKINGS_URL = apiBase ? `${apiBase}/bookings?chat_id=${encodeURIComponent(CHAT_ID)}` : '';
    const CANCEL_URL   = apiBase ? `${apiBase}/cancel_api` : '';

    const calendarEl = document.getElementById('calendar');
    const bookedMap = new Map();  // 'YYYY-MM-DD' -> { user_id, user_name }
    let calendar = null;

    // ---- utils
    function toISODate(d) {
      const dt = (d instanceof Date) ? d : new Date(d);
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const dd = String(dt.getDate()).padStart(2, '0');
      return `${y}-${m}-${dd}`;
    }
    function addDaysISO(iso, d=1) {
      const dt = new Date(iso);
      dt.setDate(dt.getDate() + d);
      return toISODate(dt);
    }

    // ---- fetch & render bookings
    async function fetchBookings() {
      bookedMap.clear();
      if (!BOOKINGS_URL) return [];
      const res = await fetch(BOOKINGS_URL, { mode: 'cors' });
      const data = await res.json().catch(() => ({}));
      const arr = Array.isArray(data.bookings) ? data.bookings : [];
      for (const b of arr) {
        if (!b.date) continue;
        bookedMap.set(String(b.date), { user_id: Number(b.user_id || 0), user_name: b.user_name || '—' });
      }
      return arr;
    }

    function toEvents(arr) {
      return arr.map(b => {
        const mine = Number(b.user_id || 0) === UID;
        return {
          id: `d:${b.date}`,
          title: b.user_name || '—',
          start: b.date,
          end: addDaysISO(b.date, 1),   // allDay end is exclusive
          allDay: true,
          display: 'block',
          classNames: [ mine ? 'mine' : 'theirs' ]
        };
      });
    }

    async function reloadEvents() {
      const arr = await fetchBookings();
      const events = toEvents(arr);
      calendar.removeAllEvents();
      calendar.addEventSource(events);
      calendar.render();
    }

    // ---- network ops (silent)
    async function sendBooking(day) {
      const payload = {
        type: 'book',
        chat_id: CHAT_ID,
        topic_id: TOPIC_ID || undefined,
        date: day,
        user_id: UID || 0,
        user_name: UNAME || 'via WebApp'
      };

      // Try via Telegram
      try { Telegram?.WebApp?.sendData?.(JSON.stringify(payload)); } catch {}

      // Duplicate to Worker (idempotent)
      if (INGEST) {
        try {
          await fetch(INGEST, {
            method: 'POST',
            mode: 'cors',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify(payload)
          });
        } catch {}
      }
    }

    async function cancelBooking(day) {
      if (!CANCEL_URL) return;
      try {
        await fetch(CANCEL_URL, {
          method:'POST', headers:{'content-type':'application/json'},
          body: JSON.stringify({ chat_id: CHAT_ID, date: day, user_id: UID })
        });
      } catch {}
    }

    // ---- unified tap handler
    async function handleDayTap(day) {
      const b = bookedMap.get(day);

      if (b) {
        // booked: if it's mine — cancel
        if (Number(b.user_id) === UID) {
          await cancelBooking(day);
          await reloadEvents();
        }
        return; // others’ booking — ignore
      }

      // free: create booking
      await sendBooking(day);
      await reloadEvents();

      // small flash
      calendar.select({ start: day, end: addDaysISO(day, 1), allDay: true });
      setTimeout(() => calendar.unselect(), 200);
    }

    // ---- init
    (async () => {
      const initial = toEvents(await fetchBookings());

      calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: true,
        selectLongPressDelay: 0,

        // events are non-editable
        editable: false,
        eventStartEditable: false,
        eventDurationEditable: false,
        eventResizableFromStart: false,

        // clicks: day or event behave the same
        dateClick: async (arg) => { await handleDayTap(toISODate(arg.date)); },
        eventClick: async (info) => { await handleDayTap(toISODate(info.event.start)); },

        // prevent selecting occupied days
        selectAllow: (info) => !bookedMap.has(toISODate(info.start)),

        events: initial,
        headerToolbar: { left:'prev,next today', center:'title', right:'' }
      });

      calendar.render();
    })();
  </script>
</body>
</html>